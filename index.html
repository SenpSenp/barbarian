<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vampire Survivor - Base (PixiJS)</title>
  <style>
    html,body { margin:0; padding:0; overflow:hidden; background:#111; }
    #game { width:1280px; height:720px; margin:0 auto; display:block; }
  </style>
  <script src="https://pixijs.download/release/pixi.min.js"></script>
</head>
<body>
<div id="game"></div>
<script>
// Single-file PixiJS base with continuous map, obstacles, enemies, scaling
const app = new PIXI.Application();
app.init({ width:1280, height:720, background:'#0b0b0b', antialias:true })
  .then(startGame)
  .catch(err => console.error('PIXI init failed', err));

function startGame(){
  document.getElementById('game').appendChild(app.canvas);
  const stage = app.stage;
  const VIEW_W = 1280, VIEW_H = 720;

  const camera = { x:0, y:0 };
  const obstacles = [];

  // Player
  const player = new PIXI.Graphics();
  player.beginFill(0x00ccff); player.drawRect(-12,-12,24,24); player.endFill();
  player.worldX = 0; player.worldY = 0; player.speed = 260; player.hp = 100;
  stage.addChild(player);

  // Entities
  let enemies = [];
  let bullets = [];

  // Timers / difficulty
  let spawnTimer = 0, spawnInterval = 900;
  let shootTimer = 0, shootInterval = 180;
  let obstacleTimer = 0, obstacleInterval = 7000; // spawn obstacles occasionally
  let kills = 0, difficultyLevel = 1;
  let maxEnemies = 12, baseEnemySpeed = 80, baseEnemyHP = 1;

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  // HUD
  const hud = new PIXI.Text('', { fontFamily:'Arial', fontSize:18, fill:0xffffff }); hud.x = 8; hud.y = 8; stage.addChild(hud);
  const centerText = new PIXI.Text('', { fontFamily:'Arial', fontSize:42, fill:0xffffff }); centerText.anchor.set(0.5); centerText.x = VIEW_W/2; centerText.y = VIEW_H/2; stage.addChild(centerText);

  function worldToScreen(wx, wy){ return { x: wx - camera.x, y: wy - camera.y }; }

  // Obstacles
  function spawnObstacle(){
    const angle = Math.random()*Math.PI*2;
    const dist = 900 + Math.random()*1200;
    const wx = player.worldX + Math.cos(angle)*dist;
    const wy = player.worldY + Math.sin(angle)*dist;

    const o = new PIXI.Graphics();
    o.beginFill(0x228833); // greenish, distinct
    const w = 60 + Math.random()*90;
    const h = 60 + Math.random()*90;
    o.drawRect(-w/2, -h/2, w, h);
    o.endFill();
    o.worldX = wx; o.worldY = wy; o.w = w; o.h = h;
    obstacles.push(o);
    stage.addChild(o);
  }

  // Spawn initial obstacles
  for(let i=0;i<6;i++) spawnObstacle();

  // Enemies
  function spawnEnemy(){
    if(enemies.length >= maxEnemies) return;
    const ang = Math.random()*Math.PI*2;
    const dist = 600 + Math.random()*300;
    const ex = player.worldX + Math.cos(ang)*dist;
    const ey = player.worldY + Math.sin(ang)*dist;

    const g = new PIXI.Graphics(); g.beginFill(0xff4466); g.drawCircle(0,0,10 + Math.random()*8); g.endFill();
    g.worldX = ex; g.worldY = ey;
    g.speed = baseEnemySpeed + Math.random()*30 + (difficultyLevel-1)*14;
    g.hp = Math.max(1, Math.round(baseEnemyHP + (difficultyLevel-1)*0.6 + Math.random()*0.6));
    g.maxHp = g.hp;

    enemies.push(g);
    stage.addChild(g);
  }

  // Bullets
  function createBullet(dirx, diry){
    const ang = Math.atan2(diry, dirx) + (Math.random()-0.5)*0.12;
    const nx = Math.cos(ang), ny = Math.sin(ang);
    const b = new PIXI.Graphics(); b.beginFill(0xffff66); b.drawRect(-4,-4,8,8); b.endFill();
    b.worldX = player.worldX; b.worldY = player.worldY; b.vx = nx*700; b.vy = ny*700; b.life = 1800; b.damage = 1;
    bullets.push(b); stage.addChild(b);
  }

  function shootAtNearest(){
    if(enemies.length===0){ for(let a=0;a<6;a++) createBullet(Math.cos(a/6*Math.PI*2), Math.sin(a/6*Math.PI*2)); return; }
    let nearest=null, dmin=1e9;
    for(const e of enemies){ const dx = e.worldX - player.worldX, dy = e.worldY - player.worldY; const d = dx*dx+dy*dy; if(d<dmin){ dmin=d; nearest=e; } }
    const dx = nearest.worldX - player.worldX, dy = nearest.worldY - player.worldY; const len = Math.hypot(dx,dy)||1; createBullet(dx/len, dy/len);
  }

  function adjustDifficulty(){ difficultyLevel++; spawnInterval = Math.max(200, spawnInterval - 80); baseEnemySpeed += 12; baseEnemyHP += 0.4; maxEnemies += 3; }

  let gameOver = false;
  function doGameOver(){ gameOver = true; centerText.text = 'GAME OVER'; app.ticker.stop(); }

  // Initial enemies
  for(let i=0;i<6;i++) spawnEnemy();

  // Main update
  function update(dt){
    if(gameOver) return;
    const delta = dt/1000;

    // Player input
    let vx=0, vy=0;
    if(keys['KeyW']||keys['ArrowUp']) vy-=1;
    if(keys['KeyS']||keys['ArrowDown']) vy+=1;
    if(keys['KeyA']||keys['ArrowLeft']) vx-=1;
    if(keys['KeyD']||keys['ArrowRight']) vx+=1;
    const m = Math.hypot(vx,vy)||1;

    // Proposed new position
    let newX = player.worldX + (vx/m)*player.speed*delta;
    let newY = player.worldY + (vy/m)*player.speed*delta;

    // Obstacle collision (AABB) - simple block
    let blocked = false;
    for(const o of obstacles){ if(newX > o.worldX - o.w/2 && newX < o.worldX + o.w/2 && newY > o.worldY - o.h/2 && newY < o.worldY + o.h/2){ blocked = true; break; } }
    if(!blocked){ player.worldX = newX; player.worldY = newY; }

    // Camera
    camera.x = player.worldX - VIEW_W/2; camera.y = player.worldY - VIEW_H/2;

    // Spawn timers
    spawnTimer += dt; if(spawnTimer >= spawnInterval){ spawnTimer = 0; spawnEnemy(); }
    shootTimer += dt; if(shootTimer >= shootInterval){ shootTimer = 0; shootAtNearest(); }
    obstacleTimer += dt; if(obstacleTimer >= obstacleInterval){ obstacleTimer = 0; spawnObstacle(); }

    // Update bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i]; b.worldX += b.vx*delta; b.worldY += b.vy*delta; b.life -= dt;
      // collision with obstacles
      let destroyed = false;
      for(const o of obstacles){ if(b.worldX > o.worldX - o.w/2 && b.worldX < o.worldX + o.w/2 && b.worldY > o.worldY - o.h/2 && b.worldY < o.worldY + o.h/2){ destroyed = true; break; } }
      if(destroyed){ stage.removeChild(b); bullets.splice(i,1); continue; }

      // remove if far or expired
      const dxp = b.worldX - player.worldX, dyp = b.worldY - player.worldY;
      if(b.life <= 0 || Math.hypot(dxp,dyp) > 3500){ stage.removeChild(b); bullets.splice(i,1); continue; }

      // collision with enemies
      for(let j=enemies.length-1;j>=0;j--){
        const e = enemies[j]; const dx = b.worldX - e.worldX, dy = b.worldY - e.worldY; if(dx*dx+dy*dy < ( (e.width||20) )*( (e.width||20) )){
          e.hp -= b.damage; stage.removeChild(b); bullets.splice(i,1);
          if(e.hp <= 0){ stage.removeChild(e); enemies.splice(j,1); kills++; if(kills % 15 === 0) adjustDifficulty(); }
          break;
        }
      }
    }

    // Update enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i]; const dx = player.worldX - e.worldX, dy = player.worldY - e.worldY; const d = Math.hypot(dx,dy)||1;
      const mx = (dx/d)*e.speed*delta, my = (dy/d)*e.speed*delta;
      let ex = e.worldX + mx, ey = e.worldY + my;
      // obstacle collision for enemies
      let hitObstacle = false;
      for(const o of obstacles){ if(ex > o.worldX - o.w/2 && ex < o.worldX + o.w/2 && ey > o.worldY - o.h/2 && ey < o.worldY + o.h/2){ hitObstacle = true; break; } }
      if(!hitObstacle){ e.worldX = ex; e.worldY = ey; }

      // remove if far
      if(Math.hypot(e.worldX - player.worldX, e.worldY - player.worldY) > 7000){ stage.removeChild(e); enemies.splice(i,1); continue; }

      // contact damage
      const collisionDist = 18 + (e.width||20);
      if(d < collisionDist){ const damagePerSecond = 8 + (difficultyLevel-1)*3; player.hp -= damagePerSecond*delta; const kb=20; player.worldX -= (dx/d)*kb*delta; player.worldY -= (dy/d)*kb*delta; player.tint = 0xff9999; setTimeout(()=>{ player.tint = 0xFFFFFF; }, 80); if(player.hp <= 0){ player.hp = 0; doGameOver(); } }
    }

    // Update render positions
    player.x = player.worldX - camera.x; player.y = player.worldY - camera.y;
    for(const o of obstacles){ const p = worldToScreen(o.worldX, o.worldY); o.x = p.x; o.y = p.y; }
    for(const e of enemies){ const p = worldToScreen(e.worldX, e.worldY); e.x = p.x; e.y = p.y; }
    for(const b of bullets){ const p = worldToScreen(b.worldX, b.worldY); b.x = p.x; b.y = p.y; }

    hud.text = `HP: ${Math.round(player.hp)}  Kills: ${kills}  Enemies: ${enemies.length}  Difficulty: ${difficultyLevel}`;
  }

  app.ticker.add(() => { update(app.ticker.elapsedMS); });
}
</script>
</body>
</html>